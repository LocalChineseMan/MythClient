package java.util.stream;

import java.util.EnumMap;
import java.util.Map;
import java.util.Spliterator;

enum StreamOpFlag {
  DISTINCT(0, 
    set(Type.SPLITERATOR).set(Type.STREAM).setAndClear(Type.OP)),
  SORTED(1, 
    set(Type.SPLITERATOR).set(Type.STREAM).setAndClear(Type.OP)),
  ORDERED(2, 
    set(Type.SPLITERATOR).set(Type.STREAM).setAndClear(Type.OP).clear(Type.TERMINAL_OP)
    .clear(Type.UPSTREAM_TERMINAL_OP)),
  SIZED(3, 
    set(Type.SPLITERATOR).set(Type.STREAM).clear(Type.OP)),
  SHORT_CIRCUIT(12, 
    set(Type.OP).set(Type.TERMINAL_OP));
  
  private static final int SET_BITS = 1;
  
  private static final int CLEAR_BITS = 2;
  
  private static final int PRESERVE_BITS = 3;
  
  private final Map<Type, Integer> maskTable;
  
  private final int bitPosition;
  
  private final int set;
  
  private final int clear;
  
  private final int preserve;
  
  static final int SPLITERATOR_CHARACTERISTICS_MASK;
  
  static final int STREAM_MASK;
  
  static final int OP_MASK;
  
  static final int TERMINAL_OP_MASK;
  
  static final int UPSTREAM_TERMINAL_OP_MASK;
  
  private static final int FLAG_MASK;
  
  private static final int FLAG_MASK_IS;
  
  private static final int FLAG_MASK_NOT;
  
  static final int INITIAL_OPS_VALUE;
  
  static final int IS_DISTINCT;
  
  static final int NOT_DISTINCT;
  
  static final int IS_SORTED;
  
  static final int NOT_SORTED;
  
  static final int IS_ORDERED;
  
  static final int NOT_ORDERED;
  
  static final int IS_SIZED;
  
  static final int NOT_SIZED;
  
  static final int IS_SHORT_CIRCUIT;
  
  enum Type {
    SPLITERATOR, STREAM, OP, TERMINAL_OP, UPSTREAM_TERMINAL_OP;
  }
  
  private static MaskBuilder set(Type paramType) {
    return (new MaskBuilder(new EnumMap<>(Type.class))).set(paramType);
  }
  
  private static class MaskBuilder {
    final Map<StreamOpFlag.Type, Integer> map;
    
    MaskBuilder(Map<StreamOpFlag.Type, Integer> param1Map) {
      this.map = param1Map;
    }
    
    MaskBuilder mask(StreamOpFlag.Type param1Type, Integer param1Integer) {
      this.map.put(param1Type, param1Integer);
      return this;
    }
    
    MaskBuilder set(StreamOpFlag.Type param1Type) {
      return mask(param1Type, Integer.valueOf(1));
    }
    
    MaskBuilder clear(StreamOpFlag.Type param1Type) {
      return mask(param1Type, Integer.valueOf(2));
    }
    
    MaskBuilder setAndClear(StreamOpFlag.Type param1Type) {
      return mask(param1Type, Integer.valueOf(3));
    }
    
    Map<StreamOpFlag.Type, Integer> build() {
      for (StreamOpFlag.Type type : StreamOpFlag.Type.values())
        this.map.putIfAbsent(type, Integer.valueOf(0)); 
      return this.map;
    }
  }
  
  StreamOpFlag(int paramInt1, MaskBuilder paramMaskBuilder) {
    this.maskTable = paramMaskBuilder.build();
    paramInt1 *= 2;
    this.bitPosition = paramInt1;
    this.set = 1 << paramInt1;
    this.clear = 2 << paramInt1;
    this.preserve = 3 << paramInt1;
  }
  
  int set() {
    return this.set;
  }
  
  int clear() {
    return this.clear;
  }
  
  boolean isStreamFlag() {
    return (((Integer)this.maskTable.get(Type.STREAM)).intValue() > 0);
  }
  
  boolean isKnown(int paramInt) {
    return ((paramInt & this.preserve) == this.set);
  }
  
  boolean isCleared(int paramInt) {
    return ((paramInt & this.preserve) == this.clear);
  }
  
  boolean isPreserved(int paramInt) {
    return ((paramInt & this.preserve) == this.preserve);
  }
  
  boolean canSet(Type paramType) {
    return ((((Integer)this.maskTable.get(paramType)).intValue() & 0x1) > 0);
  }
  
  static {
    SPLITERATOR_CHARACTERISTICS_MASK = createMask(Type.SPLITERATOR);
    STREAM_MASK = createMask(Type.STREAM);
    OP_MASK = createMask(Type.OP);
    TERMINAL_OP_MASK = createMask(Type.TERMINAL_OP);
    UPSTREAM_TERMINAL_OP_MASK = createMask(Type.UPSTREAM_TERMINAL_OP);
    FLAG_MASK = createFlagMask();
    FLAG_MASK_IS = STREAM_MASK;
    FLAG_MASK_NOT = STREAM_MASK << 1;
    INITIAL_OPS_VALUE = FLAG_MASK_IS | FLAG_MASK_NOT;
    IS_DISTINCT = DISTINCT.set;
    NOT_DISTINCT = DISTINCT.clear;
    IS_SORTED = SORTED.set;
    NOT_SORTED = SORTED.clear;
    IS_ORDERED = ORDERED.set;
    NOT_ORDERED = ORDERED.clear;
    IS_SIZED = SIZED.set;
    NOT_SIZED = SIZED.clear;
    IS_SHORT_CIRCUIT = SHORT_CIRCUIT.set;
  }
  
  private static int createMask(Type paramType) {
    int i = 0;
    for (StreamOpFlag streamOpFlag : values())
      i |= ((Integer)streamOpFlag.maskTable.get(paramType)).intValue() << streamOpFlag.bitPosition; 
    return i;
  }
  
  private static int createFlagMask() {
    int i = 0;
    for (StreamOpFlag streamOpFlag : values())
      i |= streamOpFlag.preserve; 
    return i;
  }
  
  private static int getMask(int paramInt) {
    return (paramInt == 0) ? FLAG_MASK : ((paramInt | (FLAG_MASK_IS & paramInt) << 1 | (FLAG_MASK_NOT & paramInt) >> 1) ^ 0xFFFFFFFF);
  }
  
  static int combineOpFlags(int paramInt1, int paramInt2) {
    return paramInt2 & getMask(paramInt1) | paramInt1;
  }
  
  static int toStreamFlags(int paramInt) {
    return (paramInt ^ 0xFFFFFFFF) >> 1 & FLAG_MASK_IS & paramInt;
  }
  
  static int toCharacteristics(int paramInt) {
    return paramInt & SPLITERATOR_CHARACTERISTICS_MASK;
  }
  
  static int fromCharacteristics(Spliterator<?> paramSpliterator) {
    int i = paramSpliterator.characteristics();
    if ((i & 0x4) != 0 && paramSpliterator.getComparator() != null)
      return i & SPLITERATOR_CHARACTERISTICS_MASK & 0xFFFFFFFB; 
    return i & SPLITERATOR_CHARACTERISTICS_MASK;
  }
  
  static int fromCharacteristics(int paramInt) {
    return paramInt & SPLITERATOR_CHARACTERISTICS_MASK;
  }
}
